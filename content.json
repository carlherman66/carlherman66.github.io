{"meta":{"title":"LK'Blog","subtitle":"","description":"","author":"luokui","url":"http://carlherman66.github.io","root":"/"},"pages":[{"title":"STK Python API","date":"2021-11-09T02:15:25.000Z","updated":"2021-11-09T02:35:09.237Z","comments":true,"path":"STK-Python-API/index.html","permalink":"http://carlherman66.github.io/STK-Python-API/index.html","excerpt":"","text":"关于STK Python API从历史上看，从 Python 与 STK 桌面和 STK 引擎的交互是使用win32com或comtypes Python 模块实现的。虽然这些方法仍然有效并且仍然受支持，但 STK Python API 提供了以下优点： 跨平台支持：假设遵循通常的跨平台 Python 准则，使用与 STK 引擎交互的新 API 编写的代码无需修改即可在 Windows 和 Linux 上使用。 可用性改进： STK 对象模型类型具有对 Python 帮助功能的内置支持。 新 API 为所有枚举提供了定义。使用 win32com，必须根据相应的数值手动定义枚举。 通过类型提示（基于输入模块）提供更好的 IDE 支持。 局限性： 当前不支持事件。 目前不支持引擎和 UI 插件的开发。 当前不支持通过将 IAgSTKXApplication.EnableConnect 设置为 True 来启用套接字连接。可以通过对象模型root ExecuteCommand 方法使用连接命令。 先决条件需要 Python 3.6 或更高版本、STK 或 STK Engine 已正确安装和许可。 安装车轮文件STK Python API 被打包成一个可以使用 pip 安装的轮文件。车轮文件包含在 bin/AgPythonAPI 目录中的 STK 安装中。 python -m pip install &quot;&lt;STK 安装目录&gt;/bin/AgPythonAPI/agi.stk 12 - 12.2.0 -py3-none-any.whl&quot; 验证安装确保有效的开发设置的最后一步是运行一个简单的程序来练习 API。在 Python 文件中，复制并粘贴下面的代码并运行它。一切都是为使用 STK 开发应用程序而设置的。 from agi.stk12.stkengine import STKEngine stk = STKEngine.StartApplication(noGraphics=True) print(stk.Version) 这将打印您机器上当前安装的 STK 版本。"}],"posts":[{"title":"MySql读写并发加锁","slug":"MySql读写并发加锁","date":"2021-12-22T02:35:57.000Z","updated":"2021-12-22T03:00:52.865Z","comments":true,"path":"2021/12/22/MySql读写并发加锁/","link":"","permalink":"http://carlherman66.github.io/2021/12/22/MySql%E8%AF%BB%E5%86%99%E5%B9%B6%E5%8F%91%E5%8A%A0%E9%94%81/","excerpt":"","text":"最近在进行数据库并发读写时遇到问题，具体场景为一端对表进行循环删除、插入操作，另一端对表进行循环查询，结果两个操作冲突了，结果阻塞在那里。发现是因为MySQL执行select操作时没有加锁，只是进行了数据隔离，在进行select时手动加锁便解决了这个问题。 数据库并发场景：读-读：不存在任何问题，也不需要并发控制 读-写：有线程安全问题，可能会造成事务隔离性问题，可能遇到脏读，幻读，不可重复读 写-写：有线程安全问题，可能会存在更新丢失问题，比如第一类更新丢失，第二类更新丢失 共享锁叫读锁,排他锁叫写锁读锁是共享的,它不会阻塞其他读锁;写锁是排他的,它会阻塞其他读锁和写锁; MYSQL中有两种锁粒度,锁住整张表和锁住表中一行 表锁:当某用户修改数据时,会获取写锁,此时会锁住整张表,其他用户都不能读和写,myisam引擎（MySQL 5.5版本之前使用），Mylsam在执行查询语句（select）前，会自动涉及的所有表加读锁，在执行增删改操作前，会自动给涉及的表加写锁。 行锁:当某用户修改某几行数据,会获取写锁,此时只是锁住那几行,那几行其他用户不能读和写;其他行没有影响,但是管理锁会消耗资源,innodb（5.5版本后） UNLOCK TABLES 解锁所有行 LOCK TABLES 表名 READ或者WRITE InnoDB锁问题 InnoDB与MyISAM的最大不同有两点：一是支持事务（TRANSACTION）；二是采用了行级锁。行级锁和表级锁本来就有许多不同之处，另外，事务的引入也带来了一些新问题。 1.事务（Transaction）及其ACID属性 事务是由一组SQL语句组成的逻辑处理单元，事务具有4属性，通常称为事务的ACID属性。原性性（Actomicity）：事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行。一致性（Consistent）：在事务开始和完成时，数据都必须保持一致状态。这意味着所有相关的数据规则都必须应用于事务的修改，以操持完整性；事务结束时，所有的内部数据结构（如B树索引或双向链表）也都必须是正确的。隔离性（Isolation）：数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的“独立”环境执行。这意味着事务处理过程中的中间状态对外部是不可见的，反之亦然。持久性（Durable）：事务完成之后，它对于数据的修改是永久性的，即使出现系统故障也能够保持。 2.并发事务带来的问题 相对于串行处理来说，并发事务处理能大大增加数据库资源的利用率，提高数据库系统的事务吞吐量，从而可以支持可以支持更多的用户。但并发事务处理也会带来一些问题，主要包括以下几种情况。 更新丢失（Lost Update）：当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题——最后的更新覆盖了其他事务所做的更新。例如，两个编辑人员制作了同一文档的电子副本。每个编辑人员独立地更改其副本，然后保存更改后的副本，这样就覆盖了原始文档。最后保存其更改保存其更改副本的编辑人员覆盖另一个编辑人员所做的修改。如果在一个编辑人员完成并提交事务之前，另一个编辑人员不能访问同一文件，则可避免此问题 脏读（Dirty Reads）：一个事务正在对一条记录做修改，在这个事务并提交前，这条记录的数据就处于不一致状态；这时，另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些“脏”的数据，并据此做进一步的处理，就会产生未提交的数据依赖关系。这种现象被形象地叫做“脏读”。 不可重复读（Non-Repeatable Reads）：一个事务在读取某些数据已经发生了改变、或某些记录已经被删除了！这种现象叫做“不可重复读”。 幻读（Phantom Reads）：一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为“幻读”。 3.事务隔离级别 在并发事务处理带来的问题中，“更新丢失”通常应该是完全避免的。但防止更新丢失，并不能单靠数据库事务控制器来解决，需要应用程序对要更新的数据加必要的锁来解决，因此，防止更新丢失应该是应用的责任。 “脏读”、“不可重复读”和“幻读”，其实都是数据库读一致性问题，必须由数据库提供一定的事务隔离机制来解决。数据库实现事务隔离的方式，基本可以分为以下两种。 一种是在读取数据前，对其加锁，阻止其他事务对数据进行修改。 另一种是不用加任何锁，通过一定机制生成一个数据请求时间点的一致性数据快照（Snapshot），并用这个快照来提供一定级别（语句级或事务级）的一致性读取。从用户的角度，好像是数据库可以提供同一数据的多个版本，因此，这种技术叫做数据多版本并发控制（ＭultiVersion Concurrency Control，简称MVCC或MCC），也经常称为多版本数据库。 数据库的事务隔离级别越严格，并发副作用越小，但付出的代价也就越大，因为事务隔离实质上就是使事务在一定程度上“串行化”进行，这显然与“并发”是矛盾的，同时，不同的应用对读一致性和事务隔离程度的要求也是不同的，比如许多应用对“不可重复读”和“幻读”并不敏感，可能更关心数据并发访问的能力。 为了解决“隔离”与“并发”的矛盾，ISO/ANSI SQL92定义了４个事务隔离级别，每个级别的隔离程度不同，允许出现的副作用也不同，应用可以根据自己业务逻辑要求，通过选择不同的隔离级别来平衡＂隔离＂与＂并发＂的矛盾事务４种隔离级别比较 隔离级别/读数据一致性及允许的并发副作用|读数据一致性|脏读|不可重复读|幻读–|:–:|–:未提交读（Read uncommitted）|最低级别，只能保证不读取物理上损坏的数据|是|是|是已提交读（Read committed）|语句级|否|是|是可重复读（Repeatable read）|事务级|否|否|是可序列化（Serializable）|最高级别，事务级|否|否|否 最后要说明的是：各具体数据库并不一定完全实现了上述４个隔离级别，例如，Oracle只提供Read committed和Serializable两个标准级别，另外还自己定义的Read only隔离级别：SQL Server除支持上述ISO/ANSI SQL92定义的４个级别外，还支持一个叫做＂快照＂的隔离级别，但严格来说它是一个用MVCC实现的Serializable隔离级别。ＭySQL支持全部４个隔离级别，但在具体实现时，有一些特点，比如在一些隔离级下是采用MVCC一致性读，但某些情况又不是。","categories":[],"tags":[],"author":"luokui"},{"title":"Python更新数据库速度慢的问题","slug":"Python更新数据库速度慢的问题","date":"2021-11-22T08:42:50.000Z","updated":"2021-11-22T10:43:57.415Z","comments":true,"path":"2021/11/22/Python更新数据库速度慢的问题/","link":"","permalink":"http://carlherman66.github.io/2021/11/22/Python%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E9%80%9F%E5%BA%A6%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"","text":"最近准备将STK中的卫星位置信息实时写入MySQL数据库中，发现在使用execute update一条一条进行数据更新时速度很慢，1500多条信息居然需要40s，发现是UPDATE效率低下的原因，然后寻找其它更快的方法，发现这样的全表更新很适合使用executemany批量执行 先写sql语句。要注意的是里面的参数， 不管什么类型，统一使用%s作为占位符，例如，向satellite表(name,latitude,longitude,altitude)插入数据 sql = &#39;INSERT INTO satellite(name,latitude,longitude,altitude) VALUES(%s,%s,%s,%s)&#39; 对应的param是一个tuple或者list param = ((name1,latitude1,longitude1,altitude1), (name2,latitude2,longitude2,altitude2)) 这样就包含了两条数据，通过executemany插入 cursor.executemany(sql,param) 将update换成insert后，写1584条数据时间从原先的几十秒变成不到一秒。 解决Field ‘node_id’ doesn’t have a default value 问题 写入数据库时报上述错误，其主要原因是因为mysql的中没有将主键设置为自增，所以在增加元素时获取生成主键时出现异常，将主键设为自增后错误消失。 解决删除表后重新INSERT时主键不从1开始的问题 由于需要实时向数据库写卫星位置信息，第一次写完1584条数据后删除写第二次时，主键从1585开始，使用以下语句将表设为从1开始自增。 cursor.execute(&#39;alter table satellite_LLA_test auto_increment=1&#39;)","categories":[],"tags":[],"author":"luokui"},{"title":"STK Python API","slug":"STK-Python-API","date":"2021-11-09T02:38:23.000Z","updated":"2021-11-09T02:38:42.410Z","comments":true,"path":"2021/11/09/STK-Python-API/","link":"","permalink":"http://carlherman66.github.io/2021/11/09/STK-Python-API/","excerpt":"","text":"关于STK Python API从历史上看，从 Python 与 STK 桌面和 STK 引擎的交互是使用win32com或comtypes Python 模块实现的。虽然这些方法仍然有效并且仍然受支持，但 STK Python API 提供了以下优点： 跨平台支持：假设遵循通常的跨平台 Python 准则，使用与 STK 引擎交互的新 API 编写的代码无需修改即可在 Windows 和 Linux 上使用。 可用性改进： STK 对象模型类型具有对 Python 帮助功能的内置支持。 新 API 为所有枚举提供了定义。使用 win32com，必须根据相应的数值手动定义枚举。 通过类型提示（基于输入模块）提供更好的 IDE 支持。 局限性： 当前不支持事件。 目前不支持引擎和 UI 插件的开发。 当前不支持通过将 IAgSTKXApplication.EnableConnect 设置为 True 来启用套接字连接。可以通过对象模型root ExecuteCommand 方法使用连接命令。 先决条件需要 Python 3.6 或更高版本、STK 或 STK Engine 已正确安装和许可。 安装车轮文件STK Python API 被打包成一个可以使用 pip 安装的轮文件。车轮文件包含在 bin/AgPythonAPI 目录中的 STK 安装中。 python -m pip install &quot;&lt;STK 安装目录&gt;/bin/AgPythonAPI/agi.stk 12 - 12.2.0 -py3-none-any.whl&quot; 验证安装确保有效的开发设置的最后一步是运行一个简单的程序来练习 API。在 Python 文件中，复制并粘贴下面的代码并运行它。一切都是为使用 STK 开发应用程序而设置的。 from agi.stk12.stkengine import STKEngine stk = STKEngine.StartApplication(noGraphics=True) print(stk.Version) 这将打印您机器上当前安装的 STK 版本。","categories":[],"tags":[],"author":"luokui"},{"title":"STK集成其他应用程序","slug":"STK集成其他应用程序","date":"2021-11-08T11:57:48.000Z","updated":"2021-11-09T02:14:57.392Z","comments":true,"path":"2021/11/08/STK集成其他应用程序/","link":"","permalink":"http://carlherman66.github.io/2021/11/08/STK%E9%9B%86%E6%88%90%E5%85%B6%E4%BB%96%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/","excerpt":"","text":"要将 STK 与另一个应用程序连接，可以使用各种选项，这取决于所涉及的任务类型（仅分析？分析和可视化？回放可视化？）、客户端应用程序的类型（MATLAB、自定义应用程序、MS Office 、Web 浏览器等），以及开发应用程序的环境（包括 STK MATLAB、STK 的 COM 接口、查看器控件和查看器应用程序对象模型，以及许多不同的连接库）。 Connect模块Connect 模块为您提供了一种与 STK 连接并在客户端-服务器环境中工作的简单方法。您可以使用 Connect 附带的库轻松构建与 STK 通信的应用程序。该库包含可用于将第三方应用程序连接到 STK 的函数、常量和其他消息传递功能。通过 Connect，可以生成可选的诊断消息。此外，Connect 允许您覆盖标准消息并对其进行修改或使用您自己的消息格式以与第三方应用程序兼容。这些功能使您可以更好地控制消息传递环境。 Connect 与 STK 和 3D Graphics 通信，因此您可以实时可视化事件。例如，您可以使用 Connect 从任务的发射和早期轨道提供实时遥测数据。作为场景，可以以 2D 或 3D 方式查看数据以可视化任务并帮助理解和解决可能出现的任何问题。 开始使用连接要使用来自外部应用程序或 HTML 页面的 Connect 命令与 STK 通信，您可以使用： 用于通过指定端口发送 Connect 命令的 TCP/IP 连接。此连接的默认端口是 5001，但您可以通过选择 Edit -&gt; Preferences 并选择 Connect 页面来更改它。 STK 的 COM 接口（参见集成帮助系统），可将 Connect 命令直接发送到 STK，无需通过端口进行通信。 使用 AgConnect 库 APIAgConnect 库 API 旨在为第三方应用程序提供一种通信工具，以向 STK 发送命令和从 STK 接收数据。AgConnect API 由一组函数组成，这些函数允许您打开与 STK 的连接、发送 Connect 命令并从 STK 接收数据作为响应，然后在完成后关闭连接。AgConnect API 还提供消息传递功能，允许您以各种用户定义的方式打印错误和诊断消息。如果需要，您可以覆盖消息传递功能并将其用于您自己的目的。使用 AgConnect，您只需提供您希望连接的 STK 产品的地址。可以使用返回任何预期数据的单个函数发送连接命令，从而对应用程序隐藏低级连接协议。 连接示例（C++）演示如何自动化和扩展 STK 应用程序或在 C++ 中构建自定义应用程序的 C++ 代码示例随 STK 一起提供。所有 C++ 代码示例都位于 &lt;STK 安装文件夹&gt;/CodeSamples/CodeSamples.zip/{CustomApplications | 自动化 | 扩展 }/C++/ 文件夹。由于大多数用户对默认安装位置没有写权限，我们建议您将带有 .zip 文件的 CodeSamples 文件夹复制到系统上的可写位置。该位置是您的 &lt;代码示例位置&gt;，将在下面的说明中引用。 所有 AgConnect 应用程序都必须使用AGCONNECT 预处理器定义进行编译。该_AFXDLL还需要预处理器定义。如果AGCONNECT未定义标志，编译器将无法识别AgUtMsgCommon.h. 除了源文件和头文件之外，AgConnect 还附带一个库文件 AgConnect.lib，在生成任何 AgConnect 可执行文件时必须链接该文件。 所有 AgConnect 应用程序都必须定义以下变量： char AgEAppName[ ]= &quot;&lt;AppName&gt;&quot;; &lt;AppName&gt;是您选择的任何名称，并在AgUtMsg消息中使用。如果你的源文件是用C++编写的，一定要定义AgEAppName如下： extern &quot;C&quot; &#123; char AgEAppName[ ]=&quot;&lt;AppName&gt;&quot;; &#125; 任何使用 AgConnect 函数的 C 或 C++ 程序必须包括AgConnect.h： #include &quot;AgConnect.h&quot; 必须定义四个变量。首先，标识正在使用的连接的上下文变量应初始化为NULL： char *connection1 = NULL; 其次，AgConnect 需要定义文件名字符串。文件名可以设置为 NULL，在这种情况下使用默认文件，或者它可以设置为您希望使用的 AgConnect 初始化文件： char *initFileName = NULL; 第三，AgConnect 需要知道 STK 连接的名称。该变量采用以下形式server:port： 静态字符连接名称[256] = &quot;localhost:5001&quot;; 最后，AgConnect 必须有一个地方来存储 Connect 命令返回的数据。因此，AgTConReturnInfo应该定义一个类型的变量： AgTConReturnInfo returnInfo; 此时，您可以通过调用来初始化 AgConnect： AgConInit(initFileName); 接下来，可以使用以下AgConOpenSTK()函数打开与 STK 的连接： AgConOpenSTK(&amp;connection1, NULL, connectName); context传递给此函数的变量应该传递给需要与此连接对话的任何未来函数。 现在 AgConnect 已初始化并已建立到 STK 的连接，可以使用类似于此处显示的调用将命令发送到 STK，该调用会加载场景（其文件为“C:\\STKData\\BasicScenarios\\Basic.sc” ) 到 STK： AgConProcessSTKCmd (connection1, &quot;Load / Scenario C:\\STKData\\BasicScenarios\\Basic.sc&quot;, &amp;returnInfo); 如果您希望在任何时候接收从 STK 返回的异步数据包，请使用以下命令： AgConGetAsync(connection1, &amp;returnInfo); 当您希望关闭与 STK 的连接时，请使用以下命令： AgConCloseSTK(&amp;connection1); 最后，调用： AgConShutdownConnect(); 释放 AgConnect 库内部分配的内存。在此调用之后，可以关闭应用程序。 的示例代码示出了打开到STK的连接，负载的情形下，发送AllAccess连接命令，关闭连接并打印出该数据的完整的程序。按照以下步骤在 Visual Studio 中设置 C++ 连接示例代码。 在 Visual Studio 中设置 C++ Connect 示例 打开 Visual Studio。 创建一个新项目。 在 Visual C++ &gt; 其他下，选择空项目。 为您的项目输入一个名称，然后单击“确定”。 在解决方案资源管理器中，右键单击 Source Files 文件夹并选择 Add &gt; New Item… 。 选择 C++ 文件并输入文件名，然后单击确定。 使用上面的示例代码链接并复制该页面上的所有文本。 将文本粘贴到您的“cpp”文件中。 确保您选择了 x64 配置，因为 STK 是 64 位应用程序。 右键单击项目并选择属性，然后按照以下步骤操作： a. 在 VC++ 目录下： i. 将 &lt;代码示例位置&gt;\\Connect\\Includes 添加到“包含目录”。 ii. 将 &lt;代码示例位置&gt;\\Connect\\lib\\Debug 添加到“库目录”。 b. 在 C/C++ &gt; Preprocessor 下，将“AGCONNECT”添加到“Preprocessor Definitions”。 c. 在链接器 &gt; 输入下，将“agconnect.lib”添加到“附加依赖项”。 确保您已使用 STK 安装路径更新了 Load 命令。 构建项目。 构建项目后，将 AgConnect.dll 从 &lt;代码示例位置&gt;\\Connect\\bin\\Debug 复制到项目的输出目录。","categories":[],"tags":[],"author":"luokui"},{"title":"STK编程接口","slug":"STK编程接口","date":"2021-11-08T09:02:17.000Z","updated":"2021-11-08T09:37:12.142Z","comments":true,"path":"2021/11/08/STK编程接口/","link":"","permalink":"http://carlherman66.github.io/2021/11/08/STK%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3/","excerpt":"","text":"STK编程接口提供了各种各样的选项来自动化和定制STK，并将其技术集成到其他应用程序中。其他选项允许您使用插件扩展STK，通过COM和脚本接口从外部扩展到STK，并开发自定义应用程序。选择正确的技术:选择可用于自动化STK、将STK与其他应用程序一起使用、扩展STK和STK引擎、开发定制应用程序和处理实时数据的技术的指南。 使用STK编程接口可实现以下功能：自动化重复任务使用脚本和编译语言、TCP/IP 套接字、自定义 UI 和外部产品（例如 MATLAB）的 OLE 自动化来自动化 STK 和使用 STK 引擎构建的自定义应用程序。 More info: Server 集成其他应用程序轻松地将高级 STK 2D、3D 可视化（2D 地图控件和 3D 地球控件）和分析功能（STK 应用程序对象和图形分析控件）添加到自定义应用程序中。 扩展AGI产品使用插件和自定义用户界面(UI)扩展STK GUI和STK分析引擎。 开发自定义应用程序快速构建和部署自定义软件应用程序，嵌入AGI的主要地球动力学分析和可视化引擎。 处理实时数据构建自定义数据馈送接口，专门的数据处理，和预先配置的显示设置。","categories":[],"tags":[]}],"categories":[],"tags":[]}